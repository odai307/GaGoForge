{
  "problem_id": "django-serializers-012",
  "title": "Create User Profile Serializer with Write-Only Password and Conditional Fields",
  "slug": "create-user-profile-serializer-with-write-only-password-and-conditional-fields",
  "framework": "django",
  "category": "serializers",
  "difficulty": "intermediate",
  "description": "Build a user profile serializer that handles secure password updates and shows different fields based on user permissions and context.\n\n**Business Context:**\nYour social media API needs a user profile serializer that can handle registration, profile updates, and administrative operations. The serializer should show different fields based on who's viewing the profile and ensure password security.\n\n**Given Models:**\n```python\n# models.py\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\nfrom django.utils import timezone\n\nclass CustomUser(AbstractUser):\n    # Extended user model with additional profile fields\n    bio = models.TextField(max_length=1000, blank=True)\n    profile_picture = models.ImageField(upload_to='profile_pics/', blank=True, null=True)\n    date_of_birth = models.DateField(null=True, blank=True)\n    phone_number = models.CharField(max_length=20, blank=True)\n    website = models.URLField(blank=True)\n    location = models.CharField(max_length=100, blank=True)\n    is_verified = models.BooleanField(default=False)\n    verification_date = models.DateTimeField(null=True, blank=True)\n    privacy_level = models.CharField(\n        max_length=20,\n        choices=[\n            ('public', 'Public'),\n            ('friends_only', 'Friends Only'),\n            ('private', 'Private')\n        ],\n        default='public'\n    )\n    \n    @property\n    def age(self):\n        \"\"\"Calculate user's age from date of birth.\"\"\"\n        if self.date_of_birth:\n            today = timezone.now().date()\n            return today.year - self.date_of_birth.year - (\n                (today.month, today.day) < (self.date_of_birth.month, self.date_of_birth.day)\n            )\n        return None\n    \n    @property\n    def display_name(self):\n        \"\"\"Get display name (full name if available, otherwise username).\"\"\"\n        if self.first_name and self.last_name:\n            return f\"{self.first_name} {self.last_name}\"\n        return self.username\n    \n    class Meta:\n        ordering = ['-date_joined']\n```\n\n**Requirements:**\n1. Create `UserProfileSerializer` with the following fields:\n   - Basic info (always shown): id, username, display_name, date_joined\n   - Profile info (context-dependent): bio, location, website, age\n   - Private info (self/admin only): email, phone_number, date_of_birth, is_verified\n   - Administrative info (admin only): is_active, is_staff, last_login\n2. Implement field-level security:\n   - Password field: write-only, validated for strength\n   - Email field: validated for format and uniqueness\n   - Phone number: validated for format (optional)\n3. Context-based field visibility:\n   - `request.user` can see all their own fields\n   - Staff users can see all fields for any user\n   - Public users see only basic and public profile info based on privacy_level\n4. Password handling:\n   - Create separate `password` and `password_confirmation` fields\n   - Validate password strength (min 8 chars, mixed case, numbers)\n   - Hash password before saving\n   - Allow password updates only through dedicated endpoint\n5. Update logic:\n   - Partial updates should be supported\n   - Email changes should trigger verification reset\n   - Profile picture uploads should be validated (size, type)\n6. Validation:\n   - Date of birth must be in the past and user must be at least 13\n   - Username must be alphanumeric with underscores\n   - Website URL must be valid\n\n**Expected Behavior:**\n```python\n# Self-view (full access):\n{\n    \"id\": 1,\n    \"username\": \"johndoe\",\n    \"display_name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"bio\": \"Software developer...\",\n    \"age\": 28,\n    \"phone_number\": \"+1234567890\",\n    \"is_verified\": true,\n    \"date_joined\": \"2023-01-15T10:30:00Z\"\n}\n\n# Public view (user with privacy_level='public'):\n{\n    \"id\": 1,\n    \"username\": \"johndoe\",\n    \"display_name\": \"John Doe\",\n    \"bio\": \"Software developer...\",\n    \"location\": \"New York, NY\",\n    \"date_joined\": \"2023-01-15T10:30:00Z\"\n}\n\n# Private user view (privacy_level='private'):\n{\n    \"id\": 1,\n    \"username\": \"johndoe\",\n    \"date_joined\": \"2023-01-15T10:30:00Z\"\n}\n```\n\n**Security Considerations:**\n- Never expose password hashes\n- Validate all user input thoroughly\n- Handle file uploads securely\n- Prevent mass assignment vulnerabilities\n- Use Django's built-in password validation where possible",
  "description_preview": "Build a secure user profile serializer with conditional field visibility, password validation, and context-based permissions.",
  "context_code": "# CONTEXT CODE (for reference only - you need to create the serializer)\n# This shows the CustomUser model your serializer will work with\n\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\nfrom django.utils import timezone\n\nclass CustomUser(AbstractUser):\n    bio = models.TextField(max_length=1000, blank=True)\n    profile_picture = models.ImageField(upload_to='profile_pics/', blank=True, null=True)\n    date_of_birth = models.DateField(null=True, blank=True)\n    phone_number = models.CharField(max_length=20, blank=True)\n    website = models.URLField(blank=True)\n    location = models.CharField(max_length=100, blank=True)\n    is_verified = models.BooleanField(default=False)\n    verification_date = models.DateTimeField(null=True, blank=True)\n    privacy_level = models.CharField(\n        max_length=20,\n        choices=[\n            ('public', 'Public'),\n            ('friends_only', 'Friends Only'),\n            ('private', 'Private')\n        ],\n        default='public'\n    )\n    \n    @property\n    def age(self):\n        if self.date_of_birth:\n            today = timezone.now().date()\n            return today.year - self.date_of_birth.year - (\n                (today.month, today.day) < (self.date_of_birth.month, self.date_of_birth.day)\n            )\n        return None\n    \n    @property\n    def display_name(self):\n        if self.first_name and self.last_name:\n            return f\"{self.first_name} {self.last_name}\"\n        return self.username\n    \n    class Meta:\n        ordering = ['-date_joined']\n\n# You need to import:\n# from rest_framework import serializers\n# from django.contrib.auth.password_validation import validate_password\n# from django.core.validators import URLValidator\n# from django.core.exceptions import ValidationError\n# import re",
  "starter_code": "",
  "target_area": "serializers.py",
  "validation_spec": {
    "required_imports": ["rest_framework.serializers", "django.contrib.auth.password_validation.validate_password", "django.core.validators.URLValidator", "django.core.exceptions.ValidationError", "re", ".models.CustomUser"],
    "required_structure": {
      "serializer_classes": ["UserProfileSerializer"],
      "write_only_fields": true,
      "conditional_fields": true,
      "context_aware": true,
      "password_validation": true
    },
    "behavior_patterns": [
      "class UserProfileSerializer(serializers.ModelSerializer):",
      "password = serializers.CharField(write_only=True, required=False)",
      "password_confirmation = serializers.CharField(write_only=True, required=False)",
      "display_name = serializers.ReadOnlyField()",
      "age = serializers.ReadOnlyField()",
      "def get_fields(self):",
      "fields = super().get_fields()",
      "request = self.context.get('request')",
      "if request and request.user.is_staff:",
      "return fields",
      "def validate_password(self, value):",
      "validate_password(value)",
      "if len(value) < 8:",
      "raise serializers.ValidationError",
      "def validate(self, attrs):",
      "password = attrs.get('password')",
      "password_confirmation = attrs.get('password_confirmation')",
      "if password and password != password_confirmation:",
      "raise serializers.ValidationError",
      "def validate_date_of_birth(self, value):",
      "if value and (timezone.now().date() - value).days < 13*365:",
      "raise serializers.ValidationError",
      "def update(self, instance, validated_data):",
      "password = validated_data.pop('password', None)",
      "if password:",
      "instance.set_password(password)",
      "return super().update(instance, validated_data)"
    ]
  },
  "import_weight": 15.00,
  "structure_weight": 30.00,
  "behavior_weight": 55.00,
  "passing_score": 80.00,
  "hints": [
    "Override get_fields() method to conditionally show/hide fields based on request context",
    "Use write_only=True for password fields to prevent them from being included in responses",
    "Check self.context.get('request') to access the current request and user",
    "Use Django's validate_password function for password strength validation"
  ],
  "learning_resources": [
    "https://www.django-rest-framework.org/api-guide/serializers/#dynamically-modifying-fields",
    "https://www.django-rest-framework.org/api-guide/serializers/#additional-keyword-arguments"
  ],
  "tags": ["django", "serializers", "authentication", "security", "intermediate"],
  "estimated_time_minutes": 40,
  "patterns": [
    {
      "pattern_id": "django-serializers-012-pattern-1",
      "name": "Conditional Field Serializer with Security",
      "description": "User serializer with context-based field visibility and secure password handling",
      "example_code": "# serializers.py\nfrom rest_framework import serializers\nfrom django.contrib.auth.password_validation import validate_password\nfrom django.core.validators import URLValidator\nfrom django.core.exceptions import ValidationError\nfrom django.utils import timezone\nimport re\nfrom .models import CustomUser\n\nclass UserProfileSerializer(serializers.ModelSerializer):\n    \"\"\"Serializer for user profiles with conditional field visibility and security.\"\"\"\n    \n    # Additional fields not in model\n    password = serializers.CharField(\n        write_only=True,\n        required=False,\n        style={'input_type': 'password'},\n        help_text='Leave empty if not changing password'\n    )\n    password_confirmation = serializers.CharField(\n        write_only=True,\n        required=False,\n        style={'input_type': 'password'}\n    )\n    \n    # Read-only properties from model\n    display_name = serializers.ReadOnlyField()\n    age = serializers.IntegerField(read_only=True)\n    \n    class Meta:\n        model = CustomUser\n        fields = [\n            'id', 'username', 'email', 'display_name', 'first_name', 'last_name',\n            'bio', 'profile_picture', 'date_of_birth', 'age', 'phone_number',\n            'website', 'location', 'is_verified', 'privacy_level',\n            'date_joined', 'last_login', 'is_active', 'is_staff',\n            'password', 'password_confirmation'\n        ]\n        read_only_fields = ['date_joined', 'last_login', 'is_verified']\n        extra_kwargs = {\n            'email': {'required': True},\n            'username': {\n                'validators': [],  # We'll handle validation manually\n                'help_text': 'Alphanumeric characters and underscores only'\n            }\n        }\n    \n    def get_fields(self):\n        \"\"\"Dynamically modify fields based on request context and permissions.\"\"\"\n        fields = super().get_fields()\n        request = self.context.get('request')\n        \n        if not request:\n            # No request context, show minimal fields\n            minimal_fields = ['id', 'username', 'display_name', 'date_joined']\n            return {k: v for k, v in fields.items() if k in minimal_fields}\n        \n        # Get the instance being serialized\n        instance = self.instance\n        \n        # Staff can see everything\n        if request.user.is_staff:\n            return fields\n        \n        # User viewing their own profile\n        if instance and instance == request.user:\n            # Can see all their own fields except sensitive staff fields\n            fields_to_remove = []\n            if not request.user.is_staff:\n                fields_to_remove = ['is_staff', 'is_active']\n            return {k: v for k, v in fields.items() if k not in fields_to_remove}\n        \n        # Other users viewing profile - apply privacy rules\n        if instance:\n            if instance.privacy_level == 'private':\n                # Only show basic info\n                allowed = ['id', 'username', 'date_joined']\n            elif instance.privacy_level == 'friends_only':\n                # TODO: Implement friend check\n                allowed = ['id', 'username', 'display_name', 'date_joined']\n            else:  # public\n                allowed = ['id', 'username', 'display_name', 'bio', \n                          'location', 'website', 'date_joined']\n            \n            return {k: v for k, v in fields.items() if k in allowed}\n        \n        return fields\n    \n    def validate_username(self, value):\n        \"\"\"Validate username format.\"\"\"\n        if not re.match(r'^[a-zA-Z0-9_]+$', value):\n            raise serializers.ValidationError(\n                'Username can only contain letters, numbers, and underscores.'\n            )\n        # Check uniqueness (excluding current instance for updates)\n        instance = self.instance\n        if instance:\n            exists = CustomUser.objects.filter(username=value).exclude(pk=instance.pk).exists()\n        else:\n            exists = CustomUser.objects.filter(username=value).exists()\n        \n        if exists:\n            raise serializers.ValidationError('Username already exists.')\n        return value\n    \n    def validate_email(self, value):\n        \"\"\"Validate email format and uniqueness.\"\"\"\n        if not value:\n            raise serializers.ValidationError('Email is required.')\n        \n        # Check uniqueness\n        instance = self.instance\n        if instance:\n            exists = CustomUser.objects.filter(email=value).exclude(pk=instance.pk).exists()\n        else:\n            exists = CustomUser.objects.filter(email=value).exists()\n        \n        if exists:\n            raise serializers.ValidationError('Email already registered.')\n        return value\n    \n    def validate_password(self, value):\n        \"\"\"Validate password strength.\"\"\"\n        if value:\n            # Use Django's built-in password validation\n            validate_password(value)\n            \n            # Additional custom validation\n            if len(value) < 8:\n                raise serializers.ValidationError('Password must be at least 8 characters long.')\n            if not any(c.isupper() for c in value):\n                raise serializers.ValidationError('Password must contain at least one uppercase letter.')\n            if not any(c.islower() for c in value):\n                raise serializers.ValidationError('Password must contain at least one lowercase letter.')\n            if not any(c.isdigit() for c in value):\n                raise serializers.ValidationError('Password must contain at least one number.')\n        return value\n    \n    def validate_date_of_birth(self, value):\n        \"\"\"Validate user is at least 13 years old.\"\"\"\n        if value:\n            today = timezone.now().date()\n            age = today.year - value.year - ((today.month, today.day) < (value.month, value.day))\n            if age < 13:\n                raise serializers.ValidationError('You must be at least 13 years old.')\n            if value > today:\n                raise serializers.ValidationError('Date of birth cannot be in the future.')\n        return value\n    \n    def validate_website(self, value):\n        \"\"\"Validate website URL format.\"\"\"\n        if value:\n            validator = URLValidator()\n            try:\n                validator(value)\n            except ValidationError:\n                raise serializers.ValidationError('Enter a valid URL.')\n        return value\n    \n    def validate(self, attrs):\n        \"\"\"Cross-field validation.\"\"\"\n        # Check password confirmation\n        password = attrs.get('password')\n        password_confirmation = attrs.get('password_confirmation')\n        \n        if password and password_confirmation and password != password_confirmation:\n            raise serializers.ValidationError({\n                'password_confirmation': 'Passwords do not match.'\n            })\n        \n        # If password is provided, confirmation must also be provided\n        if password and not password_confirmation:\n            raise serializers.ValidationError({\n                'password_confirmation': 'Password confirmation is required when setting password.'\n            })\n        \n        return attrs\n    \n    def create(self, validated_data):\n        \"\"\"Create user with hashed password.\"\"\"\n        password = validated_data.pop('password', None)\n        validated_data.pop('password_confirmation', None)\n        \n        user = CustomUser(**validated_data)\n        if password:\n            user.set_password(password)\n        user.save()\n        return user\n    \n    def update(self, instance, validated_data):\n        \"\"\"Update user, handling password hashing.\"\"\"\n        password = validated_data.pop('password', None)\n        validated_data.pop('password_confirmation', None)\n        \n        # Update email triggers verification reset\n        if 'email' in validated_data and validated_data['email'] != instance.email:\n            instance.is_verified = False\n            instance.verification_date = None\n        \n        # Update the instance\n        for attr, value in validated_data.items():\n            setattr(instance, attr, value)\n        \n        # Hash password if provided\n        if password:\n            instance.set_password(password)\n        \n        instance.save()\n        return instance",
      "required_imports": ["rest_framework.serializers", "django.contrib.auth.password_validation.validate_password", "django.core.validators.URLValidator", "django.utils.timezone", "re", ".models.CustomUser"],
      "required_structure": {
        "serializer_classes": ["UserProfileSerializer"],
        "overrides_get_fields": true,
        "has_password_fields": true,
        "has_multiple_validations": true,
        "has_create_update_methods": true
      },
      "forbidden_patterns": ["password in response", "no context handling", "fields = '__all__'"],
      "is_primary": true,
      "confidence_threshold": 85.00
    }
  ]
}