{
  "problem_id": "django-serializers-013",
  "title": "Create Order Serializer with Line Items and Transaction Logic",
  "slug": "create-order-serializer-with-line-items-and-transaction-logic",
  "framework": "django",
  "category": "serializers",
  "difficulty": "intermediate",
  "description": "Build a complex order serializer that handles line items, calculates totals, validates inventory, and processes transactions atomically.\n\n**Business Context:**\nYour e-commerce API needs to process orders with multiple line items, calculate totals including taxes and shipping, validate inventory availability, and handle the entire transaction atomically to prevent data inconsistencies.\n\n**Given Models:**\n```python\n# models.py\nfrom django.db import models\nfrom django.contrib.auth.models import User\nfrom django.core.validators import MinValueValidator\n\nclass Product(models.Model):\n    name = models.CharField(max_length=200)\n    sku = models.CharField(max_length=50, unique=True)\n    price = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(0.01)])\n    stock_quantity = models.PositiveIntegerField(default=0)\n    is_active = models.BooleanField(default=True)\n    tax_rate = models.DecimalField(max_digits=5, decimal_places=2, default=0.0)  # percentage\n    \n    def __str__(self):\n        return self.name\n\nclass Order(models.Model):\n    ORDER_STATUS_CHOICES = [\n        ('pending', 'Pending'),\n        ('processing', 'Processing'),\n        ('shipped', 'Shipped'),\n        ('delivered', 'Delivered'),\n        ('cancelled', 'Cancelled'),\n        ('refunded', 'Refunded'),\n    ]\n    \n    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='orders')\n    order_number = models.CharField(max_length=20, unique=True)\n    status = models.CharField(max_length=20, choices=ORDER_STATUS_CHOICES, default='pending')\n    shipping_address = models.TextField()\n    billing_address = models.TextField()\n    shipping_cost = models.DecimalField(max_digits=10, decimal_places=2, default=0.00)\n    notes = models.TextField(blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    def __str__(self):\n        return f\"Order #{self.order_number}\"\n    \n    @property\n    def subtotal(self):\n        \"\"\"Calculate sum of all line item totals.\"\"\"\n        return sum(item.total_price for item in self.items.all())\n    \n    @property\n    def tax_total(self):\n        \"\"\"Calculate total tax amount.\"\"\"\n        return sum(item.tax_amount for item in self.items.all())\n    \n    @property\n    def grand_total(self):\n        \"\"\"Calculate final total including shipping.\"\"\"\n        return self.subtotal + self.tax_total + self.shipping_cost\n\nclass OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='items')\n    product = models.ForeignKey(Product, on_delete=models.PROTECT, related_name='order_items')\n    quantity = models.PositiveIntegerField(validators=[MinValueValidator(1)])\n    unit_price = models.DecimalField(max_digits=10, decimal_places=2)  # Price at time of order\n    tax_rate = models.DecimalField(max_digits=5, decimal_places=2)  # Tax rate at time of order\n    \n    class Meta:\n        unique_together = ['order', 'product']\n    \n    def __str__(self):\n        return f\"{self.quantity}x {self.product.name}\"\n    \n    @property\n    def total_price(self):\n        \"\"\"Calculate line item total before tax.\"\"\"\n        return self.quantity * self.unit_price\n    \n    @property\n    def tax_amount(self):\n        \"\"\"Calculate tax for this line item.\"\"\"\n        return self.total_price * (self.tax_rate / 100)\n    \n    @property\n    def total_with_tax(self):\n        \"\"\"Calculate line item total including tax.\"\"\"\n        return self.total_price + self.tax_amount\n```\n\n**Requirements:**\n1. Create serializers for the complete order workflow:\n   - `ProductSerializer`: Basic product info for reference\n   - `OrderItemSerializer`: Handles line items with validation\n   - `OrderSerializer`: Main serializer with nested line items\n2. Implement complex validation:\n   - Inventory check: Ensure sufficient stock for each product\n   - Price validation: Unit price should match current product price (Â±10% tolerance for price changes)\n   - Tax calculation: Use product's tax rate or default\n   - Minimum order value: $10.00 minimum\n   - Maximum items: 50 items per order\n3. Atomic transaction processing:\n   - Create order and all line items in a single database transaction\n   - Update product stock quantities atomically\n   - Generate unique order number automatically\n4. Calculated fields in serializers:\n   - All calculated properties should be included in responses\n   - Read-only calculated totals (subtotal, tax_total, grand_total)\n   - Per-line item calculations\n5. Write operations:\n   - Create new orders with line items\n   - Update order status (with validation of status transitions)\n   - Cancel orders (restore inventory if not shipped)\n6. Business logic:\n   - Shipping cost calculation based on subtotal (free over $100)\n   - Tax exemption for certain products or users\n   - Discount code application (bonus: implement simple discount logic)\n\n**Expected Behavior:**\n```python\n# Request payload for order creation:\n{\n    \"user\": 1,\n    \"shipping_address\": \"123 Main St, City, State 12345\",\n    \"billing_address\": \"123 Main St, City, State 12345\",\n    \"notes\": \"Please deliver after 5 PM\",\n    \"items\": [\n        {\n            \"product\": 101,\n            \"quantity\": 2\n        },\n        {\n            \"product\": 205,\n            \"quantity\": 1\n        }\n    ]\n}\n\n# Response should include:\n{\n    \"id\": 456,\n    \"order_number\": \"ORD-2023-00456\",\n    \"status\": \"pending\",\n    \"subtotal\": \"149.98\",\n    \"tax_total\": \"12.49\",\n    \"shipping_cost\": \"5.99\",\n    \"grand_total\": \"168.46\",\n    \"items\": [\n        {\n            \"id\": 1,\n            \"product\": {\"id\": 101, \"name\": \"Wireless Headphones\", \"sku\": \"WH-001\"},\n            \"quantity\": 2,\n            \"unit_price\": \"59.99\",\n            \"tax_rate\": \"8.25\",\n            \"total_price\": \"119.98\",\n            \"tax_amount\": \"9.90\",\n            \"total_with_tax\": \"129.88\"\n        }\n    ],\n    \"created_at\": \"2023-10-15T14:30:00Z\"\n}\n```\n\n**Performance & Integrity Requirements:**\n- Use database transactions to ensure consistency\n- Prevent race conditions on inventory updates\n- Validate all business rules before committing\n- Generate unique order numbers without gaps\n- Handle concurrent order creation gracefully",
  "description_preview": "Create a comprehensive order serializer with nested line items, inventory validation, atomic transactions, and complex business logic.",
  "context_code": "# CONTEXT CODE (for reference only - you need to create serializers)\n# This shows the models your serializers will work with\n\nfrom django.db import models\nfrom django.contrib.auth.models import User\nfrom django.core.validators import MinValueValidator\n\nclass Product(models.Model):\n    name = models.CharField(max_length=200)\n    sku = models.CharField(max_length=50, unique=True)\n    price = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(0.01)])\n    stock_quantity = models.PositiveIntegerField(default=0)\n    is_active = models.BooleanField(default=True)\n    tax_rate = models.DecimalField(max_digits=5, decimal_places=2, default=0.0)\n    \n    def __str__(self):\n        return self.name\n\nclass Order(models.Model):\n    ORDER_STATUS_CHOICES = [\n        ('pending', 'Pending'),\n        ('processing', 'Processing'),\n        ('shipped', 'Shipped'),\n        ('delivered', 'Delivered'),\n        ('cancelled', 'Cancelled'),\n        ('refunded', 'Refunded'),\n    ]\n    \n    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='orders')\n    order_number = models.CharField(max_length=20, unique=True)\n    status = models.CharField(max_length=20, choices=ORDER_STATUS_CHOICES, default='pending')\n    shipping_address = models.TextField()\n    billing_address = models.TextField()\n    shipping_cost = models.DecimalField(max_digits=10, decimal_places=2, default=0.00)\n    notes = models.TextField(blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    def __str__(self):\n        return f\"Order #{self.order_number}\"\n    \n    @property\n    def subtotal(self):\n        return sum(item.total_price for item in self.items.all())\n    \n    @property\n    def tax_total(self):\n        return sum(item.tax_amount for item in self.items.all())\n    \n    @property\n    def grand_total(self):\n        return self.subtotal + self.tax_total + self.shipping_cost\n\nclass OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='items')\n    product = models.ForeignKey(Product, on_delete=models.PROTECT, related_name='order_items')\n    quantity = models.PositiveIntegerField(validators=[MinValueValidator(1)])\n    unit_price = models.DecimalField(max_digits=10, decimal_places=2)\n    tax_rate = models.DecimalField(max_digits=5, decimal_places=2)\n    \n    class Meta:\n        unique_together = ['order', 'product']\n    \n    def __str__(self):\n        return f\"{self.quantity}x {self.product.name}\"\n    \n    @property\n    def total_price(self):\n        return self.quantity * self.unit_price\n    \n    @property\n    def tax_amount(self):\n        return self.total_price * (self.tax_rate / 100)\n    \n    @property\n    def total_with_tax(self):\n        return self.total_price + self.tax_amount\n\n# You need to import:\n# from rest_framework import serializers\n# from django.db import transaction\n# from django.utils import timezone\n# import random\n# import string",
  "starter_code": "",
  "target_area": "serializers.py",
  "validation_spec": {
    "required_imports": ["rest_framework.serializers", "django.db.transaction", "django.utils.timezone", "random", "string", ".models.Product", ".models.Order", ".models.OrderItem"],
    "required_structure": {
      "serializer_classes": ["ProductSerializer", "OrderItemSerializer", "OrderSerializer"],
      "nested_writable": true,
      "atomic_transaction": true,
      "business_logic": true,
      "inventory_validation": true
    },
    "behavior_patterns": [
      "class ProductSerializer(serializers.ModelSerializer):",
      "class Meta:",
      "model = Product",
      "fields = ['id', 'name', 'sku', 'price', 'stock_quantity', 'tax_rate']",
      "class OrderItemSerializer(serializers.ModelSerializer):",
      "product = ProductSerializer(read_only=True)",
      "product_id = serializers.PrimaryKeyRelatedField",
      "queryset=Product.objects.filter(is_active=True)",
      "write_only=True",
      "total_price = serializers.DecimalField(read_only=True)",
      "tax_amount = serializers.DecimalField(read_only=True)",
      "total_with_tax = serializers.DecimalField(read_only=True)",
      "def validate(self, attrs):",
      "product = attrs.get('product')",
      "quantity = attrs.get('quantity')",
      "if product.stock_quantity < quantity:",
      "raise serializers.ValidationError",
      "class OrderSerializer(serializers.ModelSerializer):",
      "items = OrderItemSerializer(many=True)",
      "subtotal = serializers.DecimalField(read_only=True, max_digits=12, decimal_places=2)",
      "tax_total = serializers.DecimalField(read_only=True, max_digits=12, decimal_places=2)",
      "grand_total = serializers.DecimalField(read_only=True, max_digits=12, decimal_places=2)",
      "def validate_items(self, value):",
      "if len(value) > 50:",
      "raise serializers.ValidationError",
      "if not value:",
      "raise serializers.ValidationError",
      "@transaction.atomic",
      "def create(self, validated_data):",
      "items_data = validated_data.pop('items')",
      "order = Order.objects.create(**validated_data)",
      "for item_data in items_data:",
      "product = item_data['product']",
      "OrderItem.objects.create(order=order, **item_data)",
      "product.stock_quantity -= item_data['quantity']",
      "product.save()",
      "return order"
    ]
  },
  "import_weight": 10.00,
  "structure_weight": 30.00,
  "behavior_weight": 60.00,
  "passing_score": 80.00,
  "hints": [
    "Use @transaction.atomic decorator on create() method to ensure all-or-nothing operation",
    "For nested writable serializers, use PrimaryKeyRelatedField for writes and nested serializer for reads",
    "Generate order number using a combination of timestamp and random characters",
    "Use F() expressions or select_for_update() to prevent race conditions on inventory updates"
  ],
  "learning_resources": [
    "https://www.django-rest-framework.org/api-guide/serializers/#writable-nested-representations",
    "https://www.django-rest-framework.org/api-guide/relations/#primarykeyrelatedfield"
  ],
  "tags": ["django", "serializers", "e-commerce", "transactions", "intermediate"],
  "estimated_time_minutes": 45,
  "patterns": [
    {
      "pattern_id": "django-serializers-013-pattern-1",
      "name": "Nested Writable Serializer with Atomic Transaction",
      "description": "Order serializer with nested line items, inventory validation, and atomic processing",
      "example_code": "# serializers.py\nfrom rest_framework import serializers\nfrom django.db import transaction\nfrom django.db.models import F\nfrom django.utils import timezone\nimport random\nimport string\nfrom .models import Product, Order, OrderItem\n\nclass ProductSerializer(serializers.ModelSerializer):\n    \"\"\"Serializer for product reference in orders.\"\"\"\n    class Meta:\n        model = Product\n        fields = ['id', 'name', 'sku', 'price', 'stock_quantity', 'tax_rate', 'is_active']\n        read_only_fields = ['stock_quantity', 'is_active']\n\nclass OrderItemSerializer(serializers.ModelSerializer):\n    \"\"\"Serializer for order line items with validation.\"\"\"\n    \n    # For reading: nested product info\n    product = ProductSerializer(read_only=True)\n    \n    # For writing: product ID only\n    product_id = serializers.PrimaryKeyRelatedField(\n        queryset=Product.objects.filter(is_active=True),\n        write_only=True,\n        source='product'\n    )\n    \n    # Calculated fields\n    total_price = serializers.DecimalField(\n        max_digits=12, decimal_places=2, read_only=True\n    )\n    tax_amount = serializers.DecimalField(\n        max_digits=12, decimal_places=2, read_only=True\n    )\n    total_with_tax = serializers.DecimalField(\n        max_digits=12, decimal_places=2, read_only=True\n    )\n    \n    class Meta:\n        model = OrderItem\n        fields = [\n            'id', 'product', 'product_id', 'quantity',\n            'unit_price', 'tax_rate', 'total_price',\n            'tax_amount', 'total_with_tax'\n        ]\n        read_only_fields = ['unit_price', 'tax_rate']\n    \n    def validate(self, attrs):\n        \"\"\"Validate line item business rules.\"\"\"\n        product = attrs.get('product')\n        quantity = attrs.get('quantity')\n        \n        if product and quantity:\n            # Check inventory\n            if product.stock_quantity < quantity:\n                raise serializers.ValidationError({\n                    'quantity': f'Insufficient stock. Only {product.stock_quantity} available.'\n                })\n            \n            # Set current price and tax rate\n            attrs['unit_price'] = product.price\n            attrs['tax_rate'] = product.tax_rate\n            \n            # Price validation (allow 10% tolerance for price changes)\n            # This would be used for updates, not initial creation\n            \n        return attrs\n\nclass OrderSerializer(serializers.ModelSerializer):\n    \"\"\"Main order serializer with nested line items and business logic.\"\"\"\n    \n    items = OrderItemSerializer(many=True)\n    \n    # Calculated totals\n    subtotal = serializers.DecimalField(\n        max_digits=12, decimal_places=2, read_only=True\n    )\n    tax_total = serializers.DecimalField(\n        max_digits=12, decimal_places=2, read_only=True\n    )\n    grand_total = serializers.DecimalField(\n        max_digits=12, decimal_places=2, read_only=True\n    )\n    \n    class Meta:\n        model = Order\n        fields = [\n            'id', 'order_number', 'user', 'status', 'shipping_address',\n            'billing_address', 'shipping_cost', 'notes', 'items',\n            'subtotal', 'tax_total', 'grand_total', 'created_at', 'updated_at'\n        ]\n        read_only_fields = ['order_number', 'status', 'shipping_cost', 'created_at', 'updated_at']\n    \n    def validate_items(self, value):\n        \"\"\"Validate order-level item constraints.\"\"\"\n        if not value:\n            raise serializers.ValidationError('Order must have at least one item.')\n        \n        if len(value) > 50:\n            raise serializers.ValidationError('Order cannot have more than 50 items.')\n        \n        # Check for duplicate products\n        product_ids = [item['product'].id for item in value]\n        if len(product_ids) != len(set(product_ids)):\n            raise serializers.ValidationError('Duplicate products in order items.')\n        \n        # Calculate minimum order value\n        total_value = sum(\n            item['product'].price * item['quantity'] \n            for item in value\n        )\n        if total_value < 10.00:\n            raise serializers.ValidationError('Minimum order value is $10.00.')\n        \n        return value\n    \n    def validate(self, attrs):\n        \"\"\"Cross-field validation.\"\"\"\n        # Ensure shipping and billing addresses are provided\n        if not attrs.get('shipping_address'):\n            raise serializers.ValidationError({\n                'shipping_address': 'Shipping address is required.'\n            })\n        \n        if not attrs.get('billing_address'):\n            raise serializers.ValidationError({\n                'billing_address': 'Billing address is required.'\n            })\n        \n        return attrs\n    \n    def generate_order_number(self):\n        \"\"\"Generate unique order number.\"\"\"\n        timestamp = timezone.now().strftime('%Y%m%d')\n        random_str = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))\n        return f\"ORD-{timestamp}-{random_str}\"\n    \n    def calculate_shipping_cost(self, subtotal):\n        \"\"\"Calculate shipping cost based on order value.\"\"\"\n        if subtotal >= 100.00:\n            return 0.00  # Free shipping over $100\n        elif subtotal >= 50.00:\n            return 5.99  # Reduced shipping\n        else:\n            return 9.99  # Standard shipping\n    \n    @transaction.atomic\n    def create(self, validated_data):\n        \"\"\"Create order with line items in atomic transaction.\"\"\"\n        items_data = validated_data.pop('items')\n        \n        # Generate order number\n        order_number = self.generate_order_number()\n        \n        # Create order instance\n        order = Order.objects.create(\n            order_number=order_number,\n            **validated_data\n        )\n        \n        total_subtotal = 0\n        \n        # Create order items and update inventory\n        for item_data in items_data:\n            product = item_data['product']\n            quantity = item_data['quantity']\n            \n            # Create order item\n            OrderItem.objects.create(\n                order=order,\n                product=product,\n                quantity=quantity,\n                unit_price=product.price,\n                tax_rate=product.tax_rate\n            )\n            \n            # Update product inventory using F() to prevent race conditions\n            Product.objects.filter(pk=product.pk).update(\n                stock_quantity=F('stock_quantity') - quantity\n            )\n            \n            # Calculate subtotal for shipping\n            total_subtotal += product.price * quantity\n        \n        # Calculate and set shipping cost\n        order.shipping_cost = self.calculate_shipping_cost(total_subtotal)\n        order.save()\n        \n        return order\n    \n    def update(self, instance, validated_data):\n        \"\"\"Update order with status transition validation.\"\"\"\n        # Handle status updates with validation\n        new_status = validated_data.get('status', instance.status)\n        old_status = instance.status\n        \n        # Validate status transitions\n        valid_transitions = {\n            'pending': ['processing', 'cancelled'],\n            'processing': ['shipped', 'cancelled'],\n            'shipped': ['delivered'],\n            'delivered': ['refunded'],\n            'cancelled': [],\n            'refunded': []\n        }\n        \n        if new_status != old_status:\n            if new_status not in valid_transitions.get(old_status, []):\n                raise serializers.ValidationError({\n                    'status': f'Cannot change status from {old_status} to {new_status}.'\n                })\n            \n            # Handle cancelled order - restore inventory\n            if new_status == 'cancelled' and old_status in ['pending', 'processing']:\n                for item in instance.items.all():\n                    Product.objects.filter(pk=item.product.pk).update(\n                        stock_quantity=F('stock_quantity') + item.quantity\n                    )\n        \n        return super().update(instance, validated_data)",
      "required_imports": ["rest_framework.serializers", "django.db.transaction", "django.db.models.F", "django.utils.timezone", "random", "string", ".models.Product", ".models.Order", ".models.OrderItem"],
      "required_structure": {
        "serializer_classes": ["ProductSerializer", "OrderItemSerializer", "OrderSerializer"],
        "has_writable_nested": true,
        "has_atomic_create": true,
        "has_inventory_updates": true,
        "has_status_validation": true
      },
      "forbidden_patterns": ["no transaction handling", "race conditions", "hardcoded business logic"],
      "is_primary": true,
      "confidence_threshold": 85.00
    }
  ]
}